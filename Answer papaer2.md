 *MBR stands for Master Noot Record
 *GPT stands for GUID(Globle Unique Identifier) Partition Table. 
 *இரண்டும் கட்டடக்கலை(architecturally) ரீதியாக வேறுபட்டவை என்றாலும், இருவரும் நிர்வகிப்பதில்(governing) ஒரே பாத்திரத்தை வகிக்கிறார்கள்(same role) மற்றும் வன் வட்டில் உள்ள பகிர்வுகளுக்கான(partitions in the hard disk) தகவல்களை வழங்குகிறார்கள்.


MBR:
	*வன் வட்டில் பகிர்வை நிர்வகிப்பதற்கான பழைய தரநிலை MBR ஆகும். 
	*MBR வன் வட்டின் ஆரம்பத்திலேயே வசிக்கிறது(MBR resides beginning of hard disk), மேலும் இது சேமிப்பக சாதனத்தில் தருக்க பகிர்வுகள்(logical partitions) எவ்வாறு ஒழுங்கமைக்கப்படுகின்றன என்பது பற்றிய தகவல்களைக் கொண்டுள்ளது. 
	*கூடுதலாக, MBR ஆனது இயங்கக்கூடிய(executable code) குறியீட்டைக் கொண்டுள்ளது, இது செயலில் உள்ள OS க்கான பகிர்வுகளை ஸ்கேன் செய்து OS க்கான துவக்க குறியீடு(boot up code) / செயல்முறையை ஏற்றும்.
	*பகிர்வை பதிவு செய்ய(to record the partition) MBR 4 பகிர்வு அதாவது 32-பிட்டைப் பயன்படுத்துவதால், ஒவ்வொரு பகிர்வும் அதிகபட்சம் 2TB அளவு வரை மட்டுமே செல்ல முடியும்.
	*எம்பிஆருடன் பல ஆபத்துகள் உள்ளன. முதலாவதாக, வன் வட்டில் 4 பகிர்வுகளை மட்டுமே வைத்திருக்க முடியும், மேலும் ஒவ்வொரு பகிர்வும் 2TB அளவு மட்டுமே. பெரிய சேமிப்பிட(big storage space) இடத்தின் வன் வட்டுடன் இது நன்றாக வேலை செய்யப்போவதில்லை(உதாரணமாக 100TB). இரண்டாவதாக, பகிர்வு தகவல்களை வைத்திருக்கும் ஒரே இடம் MBR மட்டுமே. அது எப்போதாவது சிதைந்தால் (ஆம், அது மிக எளிதாக சிதைந்துவிடும்), முழு வன் வட்டு படிக்கமுடியாது(the entire hard disk is unreadable).

GPT:
	*GPT என்பது ஒரு வன் வட்டின் பகிர்வுகளை அமைப்பதற்கான சமீபத்திய தரமாகும். 
	*பகிர்வை வரையறுக்க இது உலகளவில் தனித்துவமான அடையாளங்காட்டிகளை (GUID) பயன்படுத்துகிறது, மேலும் இது UEFI தரநிலையின் ஒரு பகுதியாகும். இதன் பொருள் UEFI- அடிப்படையிலான கணினியில் (இது Windows 8 பாதுகாப்பான துவக்க அம்சத்திற்கு தேவைப்படுகிறது), GPT ஐப் பயன்படுத்த வேண்டியது அவசியம்.
	* ஜிபிடி மூலம், வன் வட்டில் கோட்பாட்டளவில் வரம்பற்ற பகிர்வுகளை உருவாக்கலாம், இது பொதுவாக பெரும்பாலான ஓஎஸ்ஸால்(OSes) 128 பகிர்வுகளுக்கு கட்டுப்படுத்தப்பட்டுள்ளது. 
	*ஒவ்வொரு பகிர்வையும் 2TB அளவுக்கு மட்டுமே கட்டுப்படுத்தும் MBR ஐப் போலன்றி, GPT இல் உள்ள ஒவ்வொரு பகிர்வும் 2 ^ 64 தொகுதிகள் வரை நீளமாக வைத்திருக்க முடியும் (இது 64-பிட்டைப் பயன்படுத்துவதால்), இது 512-பைட் தொகுதிக்கு 9.44ZB க்கு சமம் (1 ZB 1 பில்லியன் டெராபைட்டுகள்). Microsoft Windowsல், அந்த அளவு 256TB ஆக வரையறுக்கப்பட்டுள்ளது.
ஜிபிடி ஒரு காப்பு தலைப்பு(backup header) மற்றும் பகிர்வு அட்டவணையை(partition table) வட்டின் முடிவில் சேமிக்கிறது, எனவே முதன்மை அட்டவணைகள் சிதைந்திருந்தால் அதை மீட்டெடுக்க முடியும்(it can be easily recovered if the primary tables are corrupted).
	* தலைப்பு மற்றும் பகிர்வு அட்டவணையின் பிழைகள் மற்றும் ஊழல்களைக் கண்டறிய இது CRC32 செக்ஸம்களை(It carry out CRC32 checjsums) மேற்கொள்கிறது.

Kenel:
	*Kernel என்பது கணினியின் மென்பொருள் மற்றும் வன்பொருளுக்கு இடையிலான இடைமுகமாகும்.
	*கர்னல் நினைவக மேலாண்மை(kernel memory management), செயல்முறை மேலாண்மை(process management), பணி மேலாண்மை(task management), வட்டு மேலாண்மை(disk management) ஆகிய செயல்களை செய்கிறது.

User Space:
	*பயனர் இடம்(user space)என்பது சாதாரண பயனர் செயல்முறைகள் இயங்கும் இடங்களின் தொகுப்பாகும் (அதாவது கர்னலைத் தவிர மற்ற அனைத்தும்). இந்த இடத்தில் இயங்கும் பயன்பாடுகளை ஒருவருக்கொருவர் குழப்பமடையாமல்(messing with each other) நிர்வகிப்பதே கர்னலின் பங்கு(this is the role of kernel).

Kernel Space:
	* கர்னல் இடம்(kernel space), இது கர்னலின் குறியீடு சேமிக்கப்பட்ட இடமாகும், மேலும் அதன் கீழ் இயங்குகிறது.
	*பயனர் இடத்தின் கீழ் இயங்கும் செயல்முறைகள்(process running under user space) நினைவகத்தின் ஒரு குறிப்பிட்ட பகுதிக்கு மட்டுமே அணுகலைக் கொண்டுள்ளன, அதேசமயம் கர்னலுக்கு எல்லா நினைவகங்களுக்கும் அணுகல் உள்ளது(kernel has access to all of the memory). பயனர் இடத்தில் இயங்கும் செயல்முறைகளுக்கு கர்னல் இடத்திற்கு அணுகல் இல்லை(Processes runnning in user space also don't have access to the kernel space).

System call:
	*ஒரு செயல்முறைக்கும்(interface between process and operating system) இயக்க முறைமைக்கும் இடையிலான இடைமுகம் கணினி அழைப்புகளால் வழங்கப்படுகிறது.
	*பயனர் இடத்தின் செயல்முறைகள்(user space processes) கர்னலின் ஒரு சிறிய பகுதியை மட்டுமே கர்னலால் வெளிப்படுத்தப்பட்ட இடைமுகம் வழியாக அணுக முடியும் இதுவே கணினி அழைக்கிறது(system call) எனப்படுகிறது. ஒரு செயல்முறை கணினி அழைப்பைச் செய்தால், ஒரு மென்பொருள் குறுக்கீடு(a software interrupt is sent to the kernel) கர்னலுக்கு அனுப்பப்படும், பின்னர் அது பொருத்தமான குறுக்கீடு கையாளுபவரை அனுப்பி(dispatches the appropriate interrupt handler), கையாளுநர் முடிந்ததும் அதன் பணியைத் தொடர்கிறது.
	*பொதுவாக, கணினி அழைப்புகள் assembly language அறிவுறுத்தல்களாக கிடைக்கின்றன. Assembly language programmers பயன்படுத்தும் கையேடுகளிலும்(manuals) அவை சேர்க்கப்பட்டுள்ளன.
	*பயனர் பயன்முறையில் ஒரு செயல்முறைக்கு ஆதாரத்தை அணுகும்போது(when process in user mode requires access to source) கணினி அழைப்புகள்(system calls) வழக்கமாக செய்யப்படுகின்றன. கணினி அழைப்பு(then requests the kernel to provide the resource via system calls) வழியாக வளத்தை வழங்குமாறு கர்னலைக் கோருகிறது.

Types of System Calls:
	*Process control
	*File Management
	*Device Management
	*Information Maintenance
	*Communication
Mounting:
	*Mounting என்பது ஒரு செயல்முறையாகும், இதன் மூலம் இயக்க முறைமை(operating system) ஒரு சேமிப்பக சாதனத்தில் கோப்புகள் மற்றும் கோப்பகங்களை (hard drive, CD-ROM or network share) பயனர்களுக்கு கணினியின் கோப்பு முறைமை வழியாக அணுக முடியும்.
	*அடைவு மரத்தி(directory tree)ல் ஒரு குறிப்பிட்ட இடத்திற்கு ஒரு சேமிப்பக சாதனத்தை இணைக்கும் செயல் mounting ஆகும். எடுத்துக்காட்டாக, கணினி துவங்கும் போது, ஒரு குறிப்பிட்ட சேமிப்பக சாதனம் (பொதுவாக ரூட் பகிர்வு என்று அழைக்கப்படுகிறது) அடைவு மரத்தின் வேருடன் தொடர்புடையது, அதாவது, அந்த சேமிப்பக சாதனம்hat storage decice is mounted on) / (ரூட் கோப்பகத்தில்) ஏற்றப்பட்டுள்ளது.

Unmounting:
	*unmounting என்பது அந்த கோப்புகள் / கோப்புறைகளுக்கான அணுகலை அந்த இடத்திலிருந்து அகற்றுவதாகும்.

